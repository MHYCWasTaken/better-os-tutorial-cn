---
layout: post
title: 12. Content
nav_order: 99
parent: 12-C语言内核
---
*你可能想提前搜索的概念：C、目标代码、链接器、反汇编*

> 目标代码 : 编译完成的文件（如exe就是c++的目标代码之一）
> 链接器 : 将多个编译器的编译文件合并为可执行文件 [百度百科](https://baike.baidu.com/item/%E9%93%BE%E6%8E%A5%E5%99%A8/10853221#%E7%AE%80%E4%BB%8B)
> 反汇编 : 将可执行文件变成汇编文件(asm)

**目标：学习用C语言编写与汇编程序相同的低级代码**

编译
-------

让我们看看C编译器是如何编译代码的，并将其与用汇编程序生成的机器代码进行比较。

我们将开始编写一个包含函数 `function.c` 的简单程序。

打开文件并检查它。

要编译与系统无关的代码，我们需要标记 `-ffreestanding` ，因此以这种方式编译 `function.c`：

`i386-elf-gcc -ffreestanding -c function.c -o function.o`

让我们检查一下编译器生成的机器代码：

`i386-elf-objdump -d function.o`

现在我们认识到了这一点，不是吗？



链接
----

最后，为了生成二进制文件，我们将使用链接器。这其中很重要的一部分

步骤是学习高级语言如何调用函数标签。也就是偏移量

我们的函数将放在内存中的什么位置？我们实际上不知道。对于本例，我们将把偏移量放在 `0x0` 处，并使用 `binary` 格式，该格式生成没有任何标签和/或元数据的机器代码

`i386-elf-ld -o function.bin -Ttext 0x0 --oformat binary function.o`

*注意：链接时可能会出现警告，请忽略*

现在检查两个 “二进制” 文件，`function.o` 和 `function.bin` 使用`xxd`。你将看到 `.bin` 文件是机器代码，而 `.o` 文件有很多调试信息、标签等。



反编译
---------

出于好奇，我们将检查机器代码。

`ndisasm-b 32函数bin`



更多
----

我鼓励您编写更多的小程序，其特点是：


-局部变量`localvars.c`

-函数调用`functioncalls.c`

-指针`pointers.c`

然后编译和反汇编它们，并检查生成的机器代码。跟随 `os-dev.pdf` 文件的说明。试着回答这个问题：

为什么‘指针’的反汇编。和你想象的不一样？“Hello”的ASCII `0x48656c6c6f`在哪里？