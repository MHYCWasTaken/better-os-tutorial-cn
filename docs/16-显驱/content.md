---
layout: post
title: 16. Content
nav_order: 99
parent: 16-显驱
---

*您可能想提前搜索的概念：VGA字符单元、屏幕偏移*

[zip](https://mhyc.eu.org/better-os-tutorial-cn/docs/16-显驱/Lesson16.zip)

**目标：在屏幕上写字符串**


最后，我们将能够在屏幕上输出文本。这节课包含的代码比平时多一点，所以让我们一步一步来。


打开 `drivers/screen.h` 。您将看到，我们为VGA卡驱动程序定义了一些常量，并定义了三个公共函数，一个用于清除屏幕，另一个用于写入字符串，这就是著名的 `kprint` ，意思是 “内核打印”


现在打开 `drivers/screen.c` 。它首先声明我们将用于帮助 `kprint` 内核API的私有helper函数。


我们在上一课中学习了两个I/O端口访问例程，

`get` 和 `set_cursor_offset()` 。


然后是直接操作视频内存的例程 `print_char()`


最后，有三个小助手函数可以将行和列转换为偏移量，反之亦然。



kprint_at
---------


`kprint_at` 可以用 `col` 和 `row` 的 `-1` 值调用，这表示我们将在当前光标位置打印字符串。


它首先为列/行和偏移量设置三个变量。然后它迭代 `char*` 并用当前坐标调用 `print_char（）` 。


注意， `print_char` 本身返回下一个光标位置的偏移量，我们在下一个循环中重复使用它。


`kprint` 基本上是 `kprint_at` 的包装




print_char()
----------


与 `kprint_at` 类似，`print_char` 允许列/行为 `-1` 。在这种情况下，它使用 `ports.c` 例程从硬件检索光标位置。


`print_char` 还处理换行。在这种情况下，我们将把光标偏移量定位到下一行的第0列。


请记住，VGA单元格需要两个字节，一个用于字符本身，另一个用于属性。



kernel.c
--------


我们的新内核终于可以打印字符串了。

它测试正确的字符位置，跨越多行，换行，最后尝试在屏幕边界之外写入。然后会发生什么？

在下一课中，我们将学习如何滚动屏幕。